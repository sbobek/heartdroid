//=========================================================================
//
//  This file was generated by Mouse 1.6.1 at 2014-11-03 11:26:04 GMT
//  from grammar
//    '/Users/msl/Documents/AGH/heart/heartdroid/hmr_parser_generator/HMRGr
//    ammar.peg'.
//
//=========================================================================

package heart.parser.hmr;

import heart.exceptions.ModelBuildingException;
import heart.exceptions.ParsingSyntaxException;
import heart.parser.hmr.runtime.Source;
import heart.xtt.*;

import java.text.RuleBasedCollator;
import java.util.LinkedList;

public class HMRParser extends heart.parser.hmr.runtime.ParserBase
{
  final HMRSemantics sem;

  //=======================================================================
  //
  //  Initialization
  //
  //=======================================================================
  //-------------------------------------------------------------------
  //  Constructor
  //-------------------------------------------------------------------
  public HMRParser()
    {
      sem = new HMRSemantics();
      sem.rule = this;
      super.sem = sem;
    }

  //-------------------------------------------------------------------
  //  Run the parser
  //-------------------------------------------------------------------
  public boolean parse(Source src) throws ParsingSyntaxException
    {
      super.init(src);
      sem.init();
      if (Start()) return true;
      return failure();
    }

  public Type.Builder getTypeBuilder(){
    return new LinkedList<Type.Builder>(sem.getModelBuilder().getIncompleteTypes()).getFirst();
  }

  public Attribute.Builder getAttributeBuilder(){
    return new LinkedList<Attribute.Builder>(sem.getModelBuilder().getIncompleteAttributes()).getFirst();
  }

  public Table.Builder getTableBuilder(){
    return new LinkedList<Table.Builder>(sem.getModelBuilder().getIncompleteTables()).getFirst();
  }


  public Rule.Builder getRuleBuilder(){
    return new LinkedList<Rule.Builder>(sem.getModelBuilder().getIncompleteRules()).getFirst();
  }

  public XTTModel getModel() throws ModelBuildingException {
    return sem.getModel();
  }


  //-------------------------------------------------------------------
  //  Get semantics
  //-------------------------------------------------------------------
  public HMRSemantics semantics()
    { return sem; }

  //=======================================================================
  //
  //  Parsing procedures
  //
  //=======================================================================
  //=====================================================================
  //  Start = Skip* HMRelement*+ EOF {throwSyntaxError} ;
  //=====================================================================
  private boolean Start() throws ParsingSyntaxException
    {
      begin("Start");
      while (Skip());
      while (!EOF())
        if (!HMRelement()) return reject();
      sem.throwSyntaxError();
      return accept();
    }

  //=====================================================================
  //  HMRelement = (HMRtype / HMRattr / HMRschm / HMRrule) / DEPelement
  //    ~{badElement} / BADelement ~{spottedEOF} ;
  //=====================================================================
  private boolean HMRelement()
  {
    begin("HMRelement");
    if (HMRelement_0()) return accept();
    if (DEPelement()) return accept();
    else sem.badElement();
    if (BADelement()) return accept();
    else sem.spottedEOF();
    return reject();
  }

  //-------------------------------------------------------------------
  //  HMRelement_0 = HMRtype / HMRattr / HMRschm / HMRrule
  //-------------------------------------------------------------------
  private boolean HMRelement_0()
  {
    begin("");
    if (HMRtype()) return acceptInner();
    if (HMRattr()) return acceptInner();
    if (HMRschm()) return acceptInner();
    if (HMRrule()) return acceptInner();
    return rejectInner();
  }

  //=====================================================================
  //  BADelement = (String / Number / ^["."])* Dot ;
  //=====================================================================
  private boolean BADelement()
  {
    begin("BADelement");
    while (BADelement_0());
    if (!Dot()) return reject();
    return accept();
  }

  //-------------------------------------------------------------------
  //  BADelement_0 = String / Number / ^["."]
  //-------------------------------------------------------------------
  private boolean BADelement_0()
  {
    begin("");
    if (String()) return acceptInner();
    if (Number()) return acceptInner();
    if (nextNotIn("\".\"")) return acceptInner();
    return rejectInner();
  }

  //=====================================================================
  //  DEPelement = ("xtraj" / "xtpgr" / "xatgr" / "xstat" / "xcall" /
  //    "xactn" / "xhalv") (String / Number / ^["."])* Dot
  //    {deprecatedElement} ;
  //=====================================================================
  private boolean DEPelement()
  {
    begin("DEPelement");
    if (!next("xtraj")
            && !next("xtpgr")
            && !next("xatgr")
            && !next("xstat")
            && !next("xcall")
            && !next("xactn")
            && !next("xhalv")
            ) return reject();
    while (BADelement_0());
    if (!Dot()) return reject();
    sem.deprecatedElement();
    return accept();
  }

  //=====================================================================
  //  HMRtype = HMRtypeAnnotations? "xtype" LSbracket HMRtypeElement
  //    (Comma HMRtypeElement)* RSbracket Dot {addType} <xtype
  //    definition> ;
  //=====================================================================
  private boolean HMRtype()
  {
    begin("HMRtype","xtype definition");
    HMRtypeAnnotations();
    if (!next("xtype")) return reject();
    if (!LSbracket()) return reject();
    if (!HMRtypeElement()) return reject();
    while (HMRtype_0());
    if (!RSbracket()) return reject();
    if (!Dot()) return reject();
    sem.addType();
    return accept();
  }

  //-------------------------------------------------------------------
  //  HMRtype_0 = Comma HMRtypeElement
  //-------------------------------------------------------------------
  private boolean HMRtype_0()
  {
    begin("");
    if (!Comma()) return rejectInner();
    if (!HMRtypeElement()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  HMRtypeElement = HMRtypeName / HMRtypeBase / HMRtypeDomain /
  //    HMRtypeLength / HMRtypeOrdered / HMRtypeDesc / HMRtypeScale <type
  //    definition attribute> ;
  //=====================================================================
  private boolean HMRtypeElement()
  {
    begin("HMRtypeElement","type definition attribute");
    if (HMRtypeName()) return accept();
    if (HMRtypeBase()) return accept();
    if (HMRtypeDomain()) return accept();
    if (HMRtypeLength()) return accept();
    if (HMRtypeOrdered()) return accept();
    if (HMRtypeDesc()) return accept();
    if (HMRtypeScale()) return accept();
    return reject();
  }

  //=====================================================================
  //  HMRtypeName = "name" Colon String {buildTypeName} <type name> ;
  //=====================================================================
  private boolean HMRtypeName()
  {
    begin("HMRtypeName","type name");
    if (!next("name")) return reject();
    if (!Colon()) return reject();
    if (!String()) return reject();
    sem.buildTypeName();
    return accept();
  }

  //=====================================================================
  //  HMRtypeBase = "base" Colon ("numeric" / "symbolic") {buildTypeBase}
  //    <type base> ;
  //=====================================================================
  private boolean HMRtypeBase()
  {
    begin("HMRtypeBase","type base");
    if (!next("base")) return reject();
    if (!Colon()) return reject();
    if (!next("numeric")
            && !next("symbolic")
            ) return reject();
    sem.buildTypeBase();
    return accept();
  }

  //=====================================================================
  //  HMRtypeDomain = "domain" Colon (NumericValuesList /
  //    DomainSymbolsList) {buildTypeDomain} <type domain> ;
  //=====================================================================
  private boolean HMRtypeDomain()
  {
    begin("HMRtypeDomain","type domain");
    if (!next("domain")) return reject();
    if (!Colon()) return reject();
    if (!NumericValuesList()
            && !DomainSymbolsList()
            ) return reject();
    sem.buildTypeDomain();
    return accept();
  }

  //=====================================================================
  //  DomainSymbolsList = LSbracket DomainSymbol (Comma DomainSymbol)*
  //    RSbracket {buildValuesList} <symbols list> ;
  //=====================================================================
  private boolean DomainSymbolsList()
  {
    begin("DomainSymbolsList","symbols list");
    if (!LSbracket()) return reject();
    if (!DomainSymbol()) return reject();
    while (DomainSymbolsList_0());
    if (!RSbracket()) return reject();
    sem.buildValuesList();
    return accept();
  }

  //-------------------------------------------------------------------
  //  DomainSymbolsList_0 = Comma DomainSymbol
  //-------------------------------------------------------------------
  private boolean DomainSymbolsList_0()
  {
    begin("");
    if (!Comma()) return rejectInner();
    if (!DomainSymbol()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  DomainSymbol = (OrderedStringValue / StringValue) {buildPassValue}
  //    <symbol> ;
  //=====================================================================
  private boolean DomainSymbol()
  {
    begin("DomainSymbol","symbol");
    if (!OrderedStringValue()
            && !StringValue()
            ) return reject();
    sem.buildPassValue();
    return accept();
  }

  //=====================================================================
  //  HMRtypeLength = "length" Colon UInteger {buildTypeLength} <type
  //    length> ;
  //=====================================================================
  private boolean HMRtypeLength()
  {
    begin("HMRtypeLength","type length");
    if (!next("length")) return reject();
    if (!Colon()) return reject();
    if (!UInteger()) return reject();
    sem.buildTypeLength();
    return accept();
  }

  //=====================================================================
  //  HMRtypeOrdered = "ordered" Colon ("yes" / "no") {buildTypeOrdered}
  //    <type order> ;
  //=====================================================================
  private boolean HMRtypeOrdered()
  {
    begin("HMRtypeOrdered","type order");
    if (!next("ordered")) return reject();
    if (!Colon()) return reject();
    if (!next("yes")
            && !next("no")
            ) return reject();
    sem.buildTypeOrdered();
    return accept();
  }

  //=====================================================================
  //  HMRtypeDesc = "desc" Colon String {buildTypeDescription} <type
  //    description> ;
  //=====================================================================
  private boolean HMRtypeDesc()
  {
    begin("HMRtypeDesc","type description");
    if (!next("desc")) return reject();
    if (!Colon()) return reject();
    if (!String()) return reject();
    sem.buildTypeDescription();
    return accept();
  }

  //=====================================================================
  //  HMRtypeScale = "scale" Colon UInteger <type scale (deprecated)> ;
  //=====================================================================
  private boolean HMRtypeScale()
  {
    begin("HMRtypeScale","type scale (deprecated)");
    if (!next("scale")) return reject();
    if (!Colon()) return reject();
    if (!UInteger()) return reject();
    return accept();
  }

  //=====================================================================
  //  HMRattr = HMRattrAnnotations? "xattr" LSbracket HMRattrElement
  //    (Comma HMRattrElement)* RSbracket Dot {addAttribute} <xattr
  //    definition> ;
  //=====================================================================
  private boolean HMRattr()
  {
    begin("HMRattr","xattr definition");
    HMRattrAnnotations();
    if (!next("xattr")) return reject();
    if (!LSbracket()) return reject();
    if (!HMRattrElement()) return reject();
    while (HMRattr_0());
    if (!RSbracket()) return reject();
    if (!Dot()) return reject();
    sem.addAttribute();
    return accept();
  }

  //-------------------------------------------------------------------
  //  HMRattr_0 = Comma HMRattrElement
  //-------------------------------------------------------------------
  private boolean HMRattr_0()
  {
    begin("");
    if (!Comma()) return rejectInner();
    if (!HMRattrElement()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  HMRattrElement = HMRattrName / HMRattrClass / HMRattrType /
  //    HMRattrComm / HMRattrCallback / HMRattrAbbrev / HMRattrDesc
  //    <attribute element definition> ;
  //=====================================================================
  private boolean HMRattrElement()
  {
    begin("HMRattrElement","attribute element definition");
    if (HMRattrName()) return accept();
    if (HMRattrClass()) return accept();
    if (HMRattrType()) return accept();
    if (HMRattrComm()) return accept();
    if (HMRattrCallback()) return accept();
    if (HMRattrAbbrev()) return accept();
    if (HMRattrDesc()) return accept();
    return reject();
  }

  //=====================================================================
  //  HMRattrName = "name" Colon String {buildAttrName} <attribute name>
  //    ;
  //=====================================================================
  private boolean HMRattrName()
  {
    begin("HMRattrName","attribute name");
    if (!next("name")) return reject();
    if (!Colon()) return reject();
    if (!String()) return reject();
    sem.buildAttrName();
    return accept();
  }

  //=====================================================================
  //  HMRattrClass = "class" Colon ("simple" / "general")
  //    {buildAttrClass} <attribute class> ;
  //=====================================================================
  private boolean HMRattrClass()
  {
    begin("HMRattrClass","attribute class");
    if (!next("class")) return reject();
    if (!Colon()) return reject();
    if (!next("simple")
            && !next("general")
            ) return reject();
    sem.buildAttrClass();
    return accept();
  }

  //=====================================================================
  //  HMRattrType = "type" Colon String {buildAttrType} <attribute type>
  //    ;
  //=====================================================================
  private boolean HMRattrType()
  {
    begin("HMRattrType","attribute type");
    if (!next("type")) return reject();
    if (!Colon()) return reject();
    if (!String()) return reject();
    sem.buildAttrType();
    return accept();
  }

  //=====================================================================
  //  HMRattrComm = "comm" Colon ("out" / "inter" / "comm" / "in")
  //    {buildAttrComm} <attribute communication mode> ;
  //=====================================================================
  private boolean HMRattrComm()
  {
    begin("HMRattrComm","attribute communication mode");
    if (!next("comm")) return reject();
    if (!Colon()) return reject();
    if (!next("out")
            && !next("inter")
            && !next("comm")
            && !next("in")
            ) return reject();
    sem.buildAttrComm();
    return accept();
  }

  //=====================================================================
  //  HMRattrCallback = "callback" Colon Identifier {buildAttrCallback}
  //    <attribute callback name> ;
  //=====================================================================
  private boolean HMRattrCallback()
  {
    begin("HMRattrCallback","attribute callback name");
    if (!next("callback")) return reject();
    if (!Colon()) return reject();
    if (!Identifier()) return reject();
    sem.buildAttrCallback();
    return accept();
  }

  //=====================================================================
  //  HMRattrAbbrev = "abbrev" Colon String {buildAttrAbbreviation}
  //    <attribute abbreviation> ;
  //=====================================================================
  private boolean HMRattrAbbrev()
  {
    begin("HMRattrAbbrev","attribute abbreviation");
    if (!next("abbrev")) return reject();
    if (!Colon()) return reject();
    if (!String()) return reject();
    sem.buildAttrAbbreviation();
    return accept();
  }

  //=====================================================================
  //  HMRattrDesc = "desc" Colon String {buildAttrDescription} <attribute
  //    description> ;
  //=====================================================================
  private boolean HMRattrDesc()
  {
    begin("HMRattrDesc","attribute description");
    if (!next("desc")) return reject();
    if (!Colon()) return reject();
    if (!String()) return reject();
    sem.buildAttrDescription();
    return accept();
  }

  //=====================================================================
  //  HMRschm = HMRschmAnnotations? "xschm" Skip* HMRschmName (Slash
  //    HMRschmDesc)? Colon HMRschmConditions EQarrow HMRschmDecisions
  //    Skip* Dot {addTable} <xschm definition> ;
  //=====================================================================
  private boolean HMRschm()
  {
    begin("HMRschm","xschm definition");
    HMRschmAnnotations();
    if (!next("xschm")) return reject();
    while (Skip());
    if (!HMRschmName()) return reject();
    HMRschm_0();
    if (!Colon()) return reject();
    if (!HMRschmConditions()) return reject();
    if (!EQarrow()) return reject();
    if (!HMRschmDecisions()) return reject();
    while (Skip());
    if (!Dot()) return reject();
    sem.addTable();
    return accept();
  }

  //-------------------------------------------------------------------
  //  HMRschm_0 = Slash HMRschmDesc
  //-------------------------------------------------------------------
  private boolean HMRschm_0()
  {
    begin("");
    if (!Slash()) return rejectInner();
    if (!HMRschmDesc()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  HMRschmName = String {buildSchmName} <scheme name> ;
  //=====================================================================
  private boolean HMRschmName()
  {
    begin("HMRschmName","scheme name");
    if (!String()) return reject();
    sem.buildSchmName();
    return accept();
  }

  //=====================================================================
  //  HMRschmDesc = String {buildSchmDescription} <scheme description> ;
  //=====================================================================
  private boolean HMRschmDesc()
  {
    begin("HMRschmDesc","scheme description");
    if (!String()) return reject();
    sem.buildSchmDescription();
    return accept();
  }

  //=====================================================================
  //  HMRschmConditions = StringsList {buildSchmConditions} <scheme
  //    conditional attributes> ;
  //=====================================================================
  private boolean HMRschmConditions()
  {
    begin("HMRschmConditions","scheme conditional attributes");
    if (!StringsList()) return reject();
    sem.buildSchmConditions();
    return accept();
  }

  //=====================================================================
  //  HMRschmDecisions = StringsList {buildSchmDecisions} <scheme
  //    decisional attributes> ;
  //=====================================================================
  private boolean HMRschmDecisions()
  {
    begin("HMRschmDecisions","scheme decisional attributes");
    if (!StringsList()) return reject();
    sem.buildSchmDecisions();
    return accept();
  }

  //=====================================================================
  //  HMRrule = HMRruleAnnotations? "xrule" Skip* HMRruleName Colon
  //    HMRruleConditionsList EQarrow HMRruleDecisionsList (STarrow
  //    HMRruleAction)? (Colon (HMRruleToken / HMRruleTokensList))? Dot
  //    (HMRruleCertaintyFactor? Skip*) {addRule} <xrule definition> ;
  //=====================================================================
  private boolean HMRrule()
  {
    begin("HMRrule","xrule definition");
    HMRruleAnnotations();
    if (!next("xrule")) return reject();
    while (Skip());
    if (!HMRruleName()) return reject();
    if (!Colon()) return reject();
    if (!HMRruleConditionsList()) return reject();
    if (!EQarrow()) return reject();
    if (!HMRruleDecisionsList()) return reject();
    HMRrule_0();
    HMRrule_1();
    if (!Dot()) return reject();
    HMRruleCertaintyFactor();
    while (Skip());
    sem.addRule();
    return accept();
  }

  //-------------------------------------------------------------------
  //  HMRrule_0 = STarrow HMRruleAction
  //-------------------------------------------------------------------
  private boolean HMRrule_0()
  {
    begin("");
    if (!STarrow()) return rejectInner();
    if (!HMRruleAction()) return rejectInner();
    return acceptInner();
  }

  //-------------------------------------------------------------------
  //  HMRrule_1 = Colon (HMRruleToken / HMRruleTokensList)
  //-------------------------------------------------------------------
  private boolean HMRrule_1()
  {
    begin("");
    if (!Colon()) return rejectInner();
    if (!HMRruleToken()
            && !HMRruleTokensList()
            ) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  HMRruleName = HMRruleId {buildRuleName} <rule name> ;
  //=====================================================================
  private boolean HMRruleName()
  {
    begin("HMRruleName","rule name");
    if (!HMRruleId()) return reject();
    sem.buildRuleName();
    return accept();
  }

  //=====================================================================
  //  HMRruleCertaintyFactor = Skip* "#" Skip* Number
  //    {addRuleCertaintyFactor} <xrule certainty factor> ;
  //=====================================================================
  private boolean HMRruleCertaintyFactor()
  {
    begin("HMRruleCertaintyFactor","xrule certainty factor");
    while (Skip());
    if (!next('#')) return reject();
    while (Skip());
    if (!Number()) return reject();
    sem.addRuleCertaintyFactor();
    return accept();
  }

  //=====================================================================
  //  HMRruleConditionsList = LSbracket HMRruleCondition (Comma
  //    HMRruleCondition)* RSbracket <rule conditions> ;
  //=====================================================================
  private boolean HMRruleConditionsList()
  {
    begin("HMRruleConditionsList","rule conditions");
    if (!LSbracket()) return reject();
    if (!HMRruleCondition()) return reject();
    while (HMRruleConditionsList_0());
    if (!RSbracket()) return reject();
    return accept();
  }

  //-------------------------------------------------------------------
  //  HMRruleConditionsList_0 = Comma HMRruleCondition
  //-------------------------------------------------------------------
  private boolean HMRruleConditionsList_0()
  {
    begin("");
    if (!Comma()) return rejectInner();
    if (!HMRruleCondition()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  HMRruleCondition = HMRruleAttributeExpression HRCop
  //    HMRCopParameters? HRDexpression {buildRuleCondition} <condition>
  //    ;
  //=====================================================================
  private boolean HMRruleCondition()
  {
    begin("HMRruleCondition","condition");
    if (!HMRruleAttributeExpression()) return reject();
    if (!HRCop()) return reject();
    HMRCopParameters();
    if (!HRDexpression()) return reject();
    sem.buildRuleCondition();
    return accept();
  }

  //=====================================================================
  //  HRCop = Skip* ("eq" / "noteq" / "lte" / "lt" / "gte" / "gt" /
  //    "subset" / "supset" / "sim" / "notsim" / "in" / "notin") Skip*
  //    {buildRuleConditionalOperator} <conditional operator> ;
  //=====================================================================
  private boolean HRCop()
  {
    begin("HRCop","conditional operator");
    while (Skip());
    if (!next("eq")
            && !next("noteq")
            && !next("lte")
            && !next("lt")
            && !next("gte")
            && !next("gt")
            && !next("subset")
            && !next("supset")
            && !next("sim")
            && !next("notsim")
            && !next("in")
            && !next("notin")
            ) return reject();
    while (Skip());
    sem.buildRuleConditionalOperator();
    return accept();
  }

  //=====================================================================
  //  HMRCopParameters = LCbracket ("min" / "exact" / "max") Skip+
  //    Percent Skip+ "in" Skip+ TimePeriod RCbracket
  //    {buildConditionalOperatorParameters} <conditional operation
  //    parameters> ;
  //=====================================================================
  private boolean HMRCopParameters()
  {
    begin("HMRCopParameters","conditional operation parameters");
    if (!LCbracket()) return reject();
    if (!next("min")
            && !next("exact")
            && !next("max")
            ) return reject();
    if (!Skip()) return reject();
    while (Skip());
    if (!Percent()) return reject();
    if (!Skip()) return reject();
    while (Skip());
    if (!next("in")) return reject();
    if (!Skip()) return reject();
    while (Skip());
    if (!TimePeriod()) return reject();
    if (!RCbracket()) return reject();
    sem.buildConditionalOperatorParameters();
    return accept();
  }

  //=====================================================================
  //  HMRruleDecisionsList = LSbracket HMRruleDecision (Comma
  //    HMRruleDecision)* RSbracket <rule decisions> ;
  //=====================================================================
  private boolean HMRruleDecisionsList()
  {
    begin("HMRruleDecisionsList","rule decisions");
    if (!LSbracket()) return reject();
    if (!HMRruleDecision()) return reject();
    while (HMRruleDecisionsList_0());
    if (!RSbracket()) return reject();
    return accept();
  }

  //-------------------------------------------------------------------
  //  HMRruleDecisionsList_0 = Comma HMRruleDecision
  //-------------------------------------------------------------------
  private boolean HMRruleDecisionsList_0()
  {
    begin("");
    if (!Comma()) return rejectInner();
    if (!HMRruleDecision()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  HMRruleDecision = String Skip+ "set" Skip+ HRDexpression
  //    {buildRuleDecision} <decision> ;
  //=====================================================================
  private boolean HMRruleDecision()
  {
    begin("HMRruleDecision","decision");
    if (!String()) return reject();
    if (!Skip()) return reject();
    while (Skip());
    if (!next("set")) return reject();
    if (!Skip()) return reject();
    while (Skip());
    if (!HRDexpression()) return reject();
    sem.buildRuleDecision();
    return accept();
  }

  //=====================================================================
  //  HMRruleAttributeExpression = (HMRruleAttributePeriodExpression /
  //    HMRruleAttributeTimeExpression / HMRruleAttributeNameExpression)
  //    {buildPassValue} ;
  //=====================================================================
  private boolean HMRruleAttributeExpression()
  {
    begin("HMRruleAttributeExpression");
    if (!HMRruleAttributePeriodExpression()
            && !HMRruleAttributeTimeExpression()
            && !HMRruleAttributeNameExpression()
            ) return reject();
    sem.buildPassValue();
    return accept();
  }

  //=====================================================================
  //  HMRruleAttributeNameExpression = String
  //    {buildAttributeNameExpression} ;
  //=====================================================================
  private boolean HMRruleAttributeNameExpression()
  {
    begin("HMRruleAttributeNameExpression");
    if (!String()) return reject();
    sem.buildAttributeNameExpression();
    return accept();
  }

  //=====================================================================
  //  HMRruleAttributePeriodExpression = ("max" / "mean" / "min" / "med"
  //    / "stddev" / "trend" / "var" / "mode") Lbracket String Comma
  //    TimePeriod Rbracket {buildAttributePeriodExpression} ;
  //=====================================================================
  private boolean HMRruleAttributePeriodExpression()
  {
    begin("HMRruleAttributePeriodExpression");
    if (!next("max")
            && !next("mean")
            && !next("min")
            && !next("med")
            && !next("stddev")
            && !next("trend")
            && !next("var")
            && !next("mode")
            ) return reject();
    if (!Lbracket()) return reject();
    if (!String()) return reject();
    if (!Comma()) return reject();
    if (!TimePeriod()) return reject();
    if (!Rbracket()) return reject();
    sem.buildAttributePeriodExpression();
    return accept();
  }

  //=====================================================================
  //  HMRruleAttributeTimeExpression = "valat" Lbracket String Comma Time
  //    Rbracket {buildAttributeTimeExpression} ;
  //=====================================================================
  private boolean HMRruleAttributeTimeExpression()
  {
    begin("HMRruleAttributeTimeExpression");
    if (!next("valat")) return reject();
    if (!Lbracket()) return reject();
    if (!String()) return reject();
    if (!Comma()) return reject();
    if (!Time()) return reject();
    if (!Rbracket()) return reject();
    sem.buildAttributeTimeExpression();
    return accept();
  }

  //=====================================================================
  //  HRDexpression = HRDexpPrec3 {buildPassValue} <decisional
  //    expression> ;
  //=====================================================================
  private boolean HRDexpression()
  {
    begin("HRDexpression","decisional expression");
    if (!HRDexpPrec3()) return reject();
    sem.buildPassValue();
    return accept();
  }

  //=====================================================================
  //  HMRruleStaticExpression = "dom" Lbracket String Rbracket
  //    {buildDomainOperator} ;
  //=====================================================================
  private boolean HMRruleStaticExpression()
  {
    begin("HMRruleStaticExpression");
    if (!next("dom")) return reject();
    if (!Lbracket()) return reject();
    if (!String()) return reject();
    if (!Rbracket()) return reject();
    sem.buildDomainOperator();
    return accept();
  }

  //=====================================================================
  //  HRDexpPrec0 = ValuesList {buildValueExpression} / NumberValue
  //    {buildValueExpression} / HRDopPrec0 {buildPassValue} /
  //    HMRruleAttributeTimeExpression {buildPassValue} /
  //    HMRruleAttributePeriodExpression {buildPassValue} /
  //    HMRruleStaticExpression {buildPassValue} / Lbracket HRDexpression
  //    Rbracket {buildBrackettedExpression} / String
  //    {buildStringExpression} ;
  //=====================================================================
  private boolean HRDexpPrec0()
  {
    begin("HRDexpPrec0");
    if (ValuesList())
    { sem.buildValueExpression(); return accept(); }
    if (NumberValue())
    { sem.buildValueExpression(); return accept(); }
    if (HRDopPrec0())
    { sem.buildPassValue(); return accept(); }
    if (HMRruleAttributeTimeExpression())
    { sem.buildPassValue(); return accept(); }
    if (HMRruleAttributePeriodExpression())
    { sem.buildPassValue(); return accept(); }
    if (HMRruleStaticExpression())
    { sem.buildPassValue(); return accept(); }
    if (HRDexpPrec0_0())
    { sem.buildBrackettedExpression(); return accept(); }
    if (String())
    { sem.buildStringExpression(); return accept(); }
    return reject();
  }

  //-------------------------------------------------------------------
  //  HRDexpPrec0_0 = Lbracket HRDexpression Rbracket
  //-------------------------------------------------------------------
  private boolean HRDexpPrec0_0()
  {
    begin("");
    if (!Lbracket()) return rejectInner();
    if (!HRDexpression()) return rejectInner();
    if (!Rbracket()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  HRDexpPrec1 = HRDexpPrec0 (HRDopPrec1 HRDexpPrec0)*
  //    {buildAssociativeExpression} ;
  //=====================================================================
  private boolean HRDexpPrec1()
  {
    begin("HRDexpPrec1");
    if (!HRDexpPrec0()) return reject();
    while (HRDexpPrec1_0());
    sem.buildAssociativeExpression();
    return accept();
  }

  //-------------------------------------------------------------------
  //  HRDexpPrec1_0 = HRDopPrec1 HRDexpPrec0
  //-------------------------------------------------------------------
  private boolean HRDexpPrec1_0()
  {
    begin("");
    if (!HRDopPrec1()) return rejectInner();
    if (!HRDexpPrec0()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  HRDexpPrec2 = HRDexpPrec1 (HRDopPrec2 HRDexpPrec1)*
  //    {buildAssociativeExpression} ;
  //=====================================================================
  private boolean HRDexpPrec2()
  {
    begin("HRDexpPrec2");
    if (!HRDexpPrec1()) return reject();
    while (HRDexpPrec2_0());
    sem.buildAssociativeExpression();
    return accept();
  }

  //-------------------------------------------------------------------
  //  HRDexpPrec2_0 = HRDopPrec2 HRDexpPrec1
  //-------------------------------------------------------------------
  private boolean HRDexpPrec2_0()
  {
    begin("");
    if (!HRDopPrec2()) return rejectInner();
    if (!HRDexpPrec1()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  HRDexpPrec3 = HRDexpPrec2 (HRDopPrec3 HRDexpPrec2)*
  //    {buildAssociativeExpression} ;
  //=====================================================================
  private boolean HRDexpPrec3()
  {
    begin("HRDexpPrec3");
    if (!HRDexpPrec2()) return reject();
    while (HRDexpPrec3_0());
    sem.buildAssociativeExpression();
    return accept();
  }

  //-------------------------------------------------------------------
  //  HRDexpPrec3_0 = HRDopPrec3 HRDexpPrec2
  //-------------------------------------------------------------------
  private boolean HRDexpPrec3_0()
  {
    begin("");
    if (!HRDopPrec3()) return rejectInner();
    if (!HRDexpPrec2()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  HRDopPrec0 = (HRDopPrec0arg1 / HRDopPrec0arg2) {buildPassValue} ;
  //=====================================================================
  private boolean HRDopPrec0()
  {
    begin("HRDopPrec0");
    if (!HRDopPrec0arg1()
            && !HRDopPrec0arg2()
            ) return reject();
    sem.buildPassValue();
    return accept();
  }

  //=====================================================================
  //  HRDopPrec0arg1 = ("abs" / "cos" / "sin" / "tan" / "fac" / "log" /
  //    "setpower") Lbracket HRDexpression Rbracket
  //    {buildUnaryExpression} ;
  //=====================================================================
  private boolean HRDopPrec0arg1()
  {
    begin("HRDopPrec0arg1");
    if (!next("abs")
            && !next("cos")
            && !next("sin")
            && !next("tan")
            && !next("fac")
            && !next("log")
            && !next("setpower")
            ) return reject();
    if (!Lbracket()) return reject();
    if (!HRDexpression()) return reject();
    if (!Rbracket()) return reject();
    sem.buildUnaryExpression();
    return accept();
  }

  //=====================================================================
  //  HRDopPrec0arg2 = ("complement" / "except" / "intersec" / "union")
  //    Lbracket (ValuesList / HRDexpression) Comma (ValuesList /
  //    HRDexpression) Rbracket {buildBinaryExpression} ;
  //=====================================================================
  private boolean HRDopPrec0arg2()
  {
    begin("HRDopPrec0arg2");
    if (!next("complement")
            && !next("except")
            && !next("intersec")
            && !next("union")
            ) return reject();
    if (!Lbracket()) return reject();
    if (!ValuesList()
            && !HRDexpression()
            ) return reject();
    if (!Comma()) return reject();
    if (!ValuesList()
            && !HRDexpression()
            ) return reject();
    if (!Rbracket()) return reject();
    sem.buildBinaryExpression();
    return accept();
  }

  //=====================================================================
  //  HRDopPrec1 = Skip* "**" Skip* {buildOperator} <"**"> ;
  //=====================================================================
  private boolean HRDopPrec1()
  {
    begin("HRDopPrec1","\"**\"");
    while (Skip());
    if (!next("**")) return reject();
    while (Skip());
    sem.buildOperator();
    return accept();
  }

  //=====================================================================
  //  HRDopPrec2 = (Skip* "*" Skip* / Skip* "/" Skip* / Skip* "mod"
  //    Skip*) {buildOperator} <"*" or "/" or "mod"> ;
  //=====================================================================
  private boolean HRDopPrec2()
  {
    begin("HRDopPrec2","\"*\" or \"/\" or \"mod\"");
    if (!HRDopPrec2_0()
            && !HRDopPrec2_1()
            && !HRDopPrec2_2()
            ) return reject();
    sem.buildOperator();
    return accept();
  }

  //-------------------------------------------------------------------
  //  HRDopPrec2_0 = Skip* "*" Skip*
  //-------------------------------------------------------------------
  private boolean HRDopPrec2_0()
  {
    begin("");
    while (Skip());
    if (!next('*')) return rejectInner();
    while (Skip());
    return acceptInner();
  }

  //-------------------------------------------------------------------
  //  HRDopPrec2_1 = Skip* "/" Skip*
  //-------------------------------------------------------------------
  private boolean HRDopPrec2_1()
  {
    begin("");
    while (Skip());
    if (!next('/')) return rejectInner();
    while (Skip());
    return acceptInner();
  }

  //-------------------------------------------------------------------
  //  HRDopPrec2_2 = Skip* "mod" Skip*
  //-------------------------------------------------------------------
  private boolean HRDopPrec2_2()
  {
    begin("");
    while (Skip());
    if (!next("mod")) return rejectInner();
    while (Skip());
    return acceptInner();
  }

  //=====================================================================
  //  HRDopPrec3 = (Skip* "+" Skip* / Skip* "-" Skip*) {buildOperator}
  //    <"+" or "-"> ;
  //=====================================================================
  private boolean HRDopPrec3()
  {
    begin("HRDopPrec3","\"+\" or \"-\"");
    if (!HRDopPrec3_0()
            && !HRDopPrec3_1()
            ) return reject();
    sem.buildOperator();
    return accept();
  }

  //-------------------------------------------------------------------
  //  HRDopPrec3_0 = Skip* "+" Skip*
  //-------------------------------------------------------------------
  private boolean HRDopPrec3_0()
  {
    begin("");
    while (Skip());
    if (!next('+')) return rejectInner();
    while (Skip());
    return acceptInner();
  }

  //-------------------------------------------------------------------
  //  HRDopPrec3_1 = Skip* "-" Skip*
  //-------------------------------------------------------------------
  private boolean HRDopPrec3_1()
  {
    begin("");
    while (Skip());
    if (!next('-')) return rejectInner();
    while (Skip());
    return acceptInner();
  }

  //=====================================================================
  //  HMRruleAction = IdentifiersList {buildRuleActions} <rule action> ;
  //=====================================================================
  private boolean HMRruleAction()
  {
    begin("HMRruleAction","rule action");
    if (!IdentifiersList()) return reject();
    sem.buildRuleActions();
    return accept();
  }

  //=====================================================================
  //  HMRruleTokensList = LSbracket HMRruleToken (Comma HMRruleToken)*
  //    RSbracket <list of rule links> ;
  //=====================================================================
  private boolean HMRruleTokensList()
  {
    begin("HMRruleTokensList","list of rule links");
    if (!LSbracket()) return reject();
    if (!HMRruleToken()) return reject();
    while (HMRruleTokensList_0());
    if (!RSbracket()) return reject();
    return accept();
  }

  //-------------------------------------------------------------------
  //  HMRruleTokensList_0 = Comma HMRruleToken
  //-------------------------------------------------------------------
  private boolean HMRruleTokensList_0()
  {
    begin("");
    if (!Comma()) return rejectInner();
    if (!HMRruleToken()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  HMRruleToken = (HMRruleId / HMRRuleSchemeId) {buildRuleLink} <rule
  //    link> ;
  //=====================================================================
  private boolean HMRruleToken()
  {
    begin("HMRruleToken","rule link");
    if (!HMRruleId()
            && !HMRRuleSchemeId()
            ) return reject();
    sem.buildRuleLink();
    return accept();
  }

  //=====================================================================
  //  HMRruleId = String "/" HMRruleIndex {buildRuleId} <rule id> ;
  //=====================================================================
  private boolean HMRruleId()
  {
    begin("HMRruleId","rule id");
    if (!String()) return reject();
    if (!next('/')) return reject();
    if (!HMRruleIndex()) return reject();
    sem.buildRuleId();
    return accept();
  }

  //=====================================================================
  //  HMRruleIndex = Integer {buildRuleIndex} <rule index> ;
  //=====================================================================
  private boolean HMRruleIndex()
  {
    begin("HMRruleIndex","rule index");
    if (!Integer()) return reject();
    sem.buildRuleIndex();
    return accept();
  }

  //=====================================================================
  //  HMRRuleSchemeId = String {buildRuleSchemeId} <scheme id> ;
  //=====================================================================
  private boolean HMRRuleSchemeId()
  {
    begin("HMRRuleSchemeId","scheme id");
    if (!String()) return reject();
    sem.buildRuleSchemeId();
    return accept();
  }

  //=====================================================================
  //  HMRattrAnnotations = AnnotationsList {buildAttrAnnotations} ;
  //=====================================================================
  private boolean HMRattrAnnotations()
  {
    begin("HMRattrAnnotations");
    if (!AnnotationsList()) return reject();
    sem.buildAttrAnnotations();
    return accept();
  }

  //=====================================================================
  //  HMRruleAnnotations = AnnotationsList {buildRuleAnnotations} ;
  //=====================================================================
  private boolean HMRruleAnnotations()
  {
    begin("HMRruleAnnotations");
    if (!AnnotationsList()) return reject();
    sem.buildRuleAnnotations();
    return accept();
  }

  //=====================================================================
  //  HMRtypeAnnotations = AnnotationsList {buildTypeAnnotations} ;
  //=====================================================================
  private boolean HMRtypeAnnotations()
  {
    begin("HMRtypeAnnotations");
    if (!AnnotationsList()) return reject();
    sem.buildTypeAnnotations();
    return accept();
  }

  //=====================================================================
  //  HMRschmAnnotations = AnnotationsList {buildSchmAnnotations} ;
  //=====================================================================
  private boolean HMRschmAnnotations()
  {
    begin("HMRschmAnnotations");
    if (!AnnotationsList()) return reject();
    sem.buildSchmAnnotations();
    return accept();
  }

  //=====================================================================
  //  AnnotationsList = (Annotation AnnotationsSeparator)+ !(Skip / "@")
  //    {buildAnnotationsList} ;
  //=====================================================================
  private boolean AnnotationsList()
  {
    begin("AnnotationsList");
    if (!AnnotationsList_0()) return reject();
    while (AnnotationsList_0());
    if (!AnnotationsList_1()) return reject();
    sem.buildAnnotationsList();
    return accept();
  }

  //-------------------------------------------------------------------
  //  AnnotationsList_0 = Annotation AnnotationsSeparator
  //-------------------------------------------------------------------
  private boolean AnnotationsList_0()
  {
    begin("");
    if (!Annotation()) return rejectInner();
    AnnotationsSeparator();
    return acceptInner();
  }

  //-------------------------------------------------------------------
  //  AnnotationsList_1 = !(Skip / "@")
  //-------------------------------------------------------------------
  private boolean AnnotationsList_1()
  {
    begin("","not Skip / \"@\"");
    if (AnnotationsList_2()) return rejectNot();
    return acceptNot();
  }

  //-------------------------------------------------------------------
  //  AnnotationsList_2 = Skip / "@"
  //-------------------------------------------------------------------
  private boolean AnnotationsList_2()
  {
    begin("");
    if (Skip()) return acceptInner();
    if (next('@')) return acceptInner();
    return rejectInner();
  }

  //=====================================================================
  //  Annotation = "@" AnnotationString (AnnotationLBracket
  //    AnnotationValues AnnotationRBracket)? {buildAnnotation} ;
  //=====================================================================
  private boolean Annotation()
  {
    begin("Annotation");
    if (!next('@')) return reject();
    if (!AnnotationString()) return reject();
    Annotation_0();
    sem.buildAnnotation();
    return accept();
  }

  //-------------------------------------------------------------------
  //  Annotation_0 = AnnotationLBracket AnnotationValues
  //    AnnotationRBracket
  //-------------------------------------------------------------------
  private boolean Annotation_0()
  {
    begin("");
    if (!AnnotationLBracket()) return rejectInner();
    if (!AnnotationValues()) return rejectInner();
    if (!AnnotationRBracket()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  AnnotationsSeparator = Skip* ;
  //=====================================================================
  private boolean AnnotationsSeparator()
  {
    begin("AnnotationsSeparator");
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  AnnotationValues = AnnotationEquation (Comma AnnotationEquation)*
  //    {addKeyValueAnnotation} / AnnotationString {addValueAnnotation}
  //    ;
  //=====================================================================
  private boolean AnnotationValues()
  {
    begin("AnnotationValues");
    if (AnnotationValues_0())
    { sem.addKeyValueAnnotation(); return accept(); }
    if (AnnotationString())
    { sem.addValueAnnotation(); return accept(); }
    return reject();
  }

  //-------------------------------------------------------------------
  //  AnnotationValues_0 = AnnotationEquation (Comma
  //    AnnotationEquation)*
  //-------------------------------------------------------------------
  private boolean AnnotationValues_0()
  {
    begin("");
    if (!AnnotationEquation()) return rejectInner();
    while (AnnotationValues_1());
    return acceptInner();
  }

  //-------------------------------------------------------------------
  //  AnnotationValues_1 = Comma AnnotationEquation
  //-------------------------------------------------------------------
  private boolean AnnotationValues_1()
  {
    begin("");
    if (!Comma()) return rejectInner();
    if (!AnnotationEquation()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  AnnotationEquation = AnnotationString AnnotationEqSign
  //    AnnotationString {buildKeyValueEquation} <key-value assignment>
  //    ;
  //=====================================================================
  private boolean AnnotationEquation()
  {
    begin("AnnotationEquation","key-value assignment");
    if (!AnnotationString()) return reject();
    if (!AnnotationEqSign()) return reject();
    if (!AnnotationString()) return reject();
    sem.buildKeyValueEquation();
    return accept();
  }

  //=====================================================================
  //  AnnotationString = ([a-z] / [A-Z] / "-" / "_" / "." / ":" / ";" /
  //    "[" / "]" / [0-9])+ {buildNormalString} / "'" ^["'"]* "'"
  //    {buildQuotedString} ;
  //=====================================================================
  private boolean AnnotationString()
  {
    begin("AnnotationString");
    if (AnnotationString_0())
    { sem.buildNormalString(); return accept(); }
    if (AnnotationString_1())
    { sem.buildQuotedString(); return accept(); }
    return reject();
  }

  //-------------------------------------------------------------------
  //  AnnotationString_0 = ([a-z] / [A-Z] / "-" / "_" / "." / ":" / ";"
  //    / "[" / "]" / [0-9])+
  //-------------------------------------------------------------------
  private boolean AnnotationString_0()
  {
    begin("");
    if (!AnnotationString_2()) return rejectInner();
    while (AnnotationString_2());
    return acceptInner();
  }

  //-------------------------------------------------------------------
  //  AnnotationString_1 = "'" ^["'"]* "'"
  //-------------------------------------------------------------------
  private boolean AnnotationString_1()
  {
    begin("");
    if (!next('\'')) return rejectInner();
    while (nextNotIn("\"'\""));
    if (!next('\'')) return rejectInner();
    return acceptInner();
  }

  //-------------------------------------------------------------------
  //  AnnotationString_2 = [a-z] / [A-Z] / "-" / "_" / "." / ":" / ";"
  //    / "[" / "]" / [0-9]
  //-------------------------------------------------------------------
  private boolean AnnotationString_2()
  {
    begin("");
    if (nextIn('a','z')) return acceptInner();
    if (nextIn('A','Z')) return acceptInner();
    if (next('-')) return acceptInner();
    if (next('_')) return acceptInner();
    if (next('.')) return acceptInner();
    if (next(':')) return acceptInner();
    if (next(';')) return acceptInner();
    if (next('[')) return acceptInner();
    if (next(']')) return acceptInner();
    if (nextIn('0','9')) return acceptInner();
    return rejectInner();
  }

  //=====================================================================
  //  AnnotationLBracket = Skip* "(" Skip* <"("> ;
  //=====================================================================
  private boolean AnnotationLBracket()
  {
    begin("AnnotationLBracket","\"(\"");
    while (Skip());
    if (!next('(')) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  AnnotationRBracket = Skip* ")" Skip* <")"> ;
  //=====================================================================
  private boolean AnnotationRBracket()
  {
    begin("AnnotationRBracket","\")\"");
    while (Skip());
    if (!next(')')) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  AnnotationEqSign = Skip* "=" Skip* <"="> ;
  //=====================================================================
  private boolean AnnotationEqSign()
  {
    begin("AnnotationEqSign","\"=\"");
    while (Skip());
    if (!next('=')) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  Colon = Skip* ":" Skip* <":"> ;
  //=====================================================================
  private boolean Colon()
  {
    begin("Colon","\":\"");
    while (Skip());
    if (!next(':')) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  Dot = Skip* "." Skip* <"."> ;
  //=====================================================================
  private boolean Dot()
  {
    begin("Dot","\".\"");
    while (Skip());
    if (!next('.')) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  Comma = Skip* "," Skip* <","> ;
  //=====================================================================
  private boolean Comma()
  {
    begin("Comma","\",\"");
    while (Skip());
    if (!next(',')) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  LSbracket = Skip* "[" Skip* <"["> ;
  //=====================================================================
  private boolean LSbracket()
  {
    begin("LSbracket","\"[\"");
    while (Skip());
    if (!next('[')) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  RSbracket = Skip* "]" Skip* <"]"> ;
  //=====================================================================
  private boolean RSbracket()
  {
    begin("RSbracket","\"]\"");
    while (Skip());
    if (!next(']')) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  RangeOp = Skip* "to" Skip* <"to"> ;
  //=====================================================================
  private boolean RangeOp()
  {
    begin("RangeOp","\"to\"");
    while (Skip());
    if (!next("to")) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  EQarrow = Skip* "==>" Skip* <"==>"> ;
  //=====================================================================
  private boolean EQarrow()
  {
    begin("EQarrow","\"==>\"");
    while (Skip());
    if (!next("==>")) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  STarrow = Skip* "**>" Skip* <"**>"> ;
  //=====================================================================
  private boolean STarrow()
  {
    begin("STarrow","\"**>\"");
    while (Skip());
    if (!next("**>")) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  Slash = Skip* "/" Skip* <"/""> ;
  //=====================================================================
  private boolean Slash()
  {
    begin("Slash","\"/\"\"");
    while (Skip());
    if (!next('/')) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  Lbracket = Skip* "(" Skip* <"("> ;
  //=====================================================================
  private boolean Lbracket()
  {
    begin("Lbracket","\"(\"");
    while (Skip());
    if (!next('(')) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  Rbracket = Skip* ")" Skip* <")"> ;
  //=====================================================================
  private boolean Rbracket()
  {
    begin("Rbracket","\")\"");
    while (Skip());
    if (!next(')')) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  LCbracket = Skip* "{" Skip* <"{"> ;
  //=====================================================================
  private boolean LCbracket()
  {
    begin("LCbracket","\"{\"");
    while (Skip());
    if (!next('{')) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  RCbracket = Skip* "}" Skip* <"}"> ;
  //=====================================================================
  private boolean RCbracket()
  {
    begin("RCbracket","\"}\"");
    while (Skip());
    if (!next('}')) return reject();
    while (Skip());
    return accept();
  }

  //=====================================================================
  //  TimePeriod = (TimeIndexPeriod / TimeMomentPeriod) {buildPassValue}
  //    ;
  //=====================================================================
  private boolean TimePeriod()
  {
    begin("TimePeriod");
    if (!TimeIndexPeriod()
            && !TimeMomentPeriod()
            ) return reject();
    sem.buildPassValue();
    return accept();
  }

  //=====================================================================
  //  TimeIndexPeriod = TimeIndex (RangeOp / Colon) TimeIndex
  //    {buildTimeIndexRange} / TimeIndex Colon TimeIndexStep Colon
  //    TimeIndex {buildTimeIndexRangeWithStep} ;
  //=====================================================================
  private boolean TimeIndexPeriod()
  {
    begin("TimeIndexPeriod");
    if (TimeIndexPeriod_0())
    { sem.buildTimeIndexRange(); return accept(); }
    if (TimeIndexPeriod_1())
    { sem.buildTimeIndexRangeWithStep(); return accept(); }
    return reject();
  }

  //-------------------------------------------------------------------
  //  TimeIndexPeriod_0 = TimeIndex (RangeOp / Colon) TimeIndex
  //-------------------------------------------------------------------
  private boolean TimeIndexPeriod_0()
  {
    begin("");
    if (!TimeIndex()) return rejectInner();
    if (!RangeOp()
            && !Colon()
            ) return rejectInner();
    if (!TimeIndex()) return rejectInner();
    return acceptInner();
  }

  //-------------------------------------------------------------------
  //  TimeIndexPeriod_1 = TimeIndex Colon TimeIndexStep Colon
  //    TimeIndex
  //-------------------------------------------------------------------
  private boolean TimeIndexPeriod_1()
  {
    begin("");
    if (!TimeIndex()) return rejectInner();
    if (!Colon()) return rejectInner();
    if (!TimeIndexStep()) return rejectInner();
    if (!Colon()) return rejectInner();
    if (!TimeIndex()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  TimeMomentPeriod = TimeMoment (RangeOp / Colon) TimeMoment
  //    {buildTimeMomentRange} / TimeMoment Colon TimeMomentStep Colon
  //    TimeMoment {buildTimeMomentRangeWithStep} ;
  //=====================================================================
  private boolean TimeMomentPeriod()
  {
    begin("TimeMomentPeriod");
    if (TimeMomentPeriod_0())
    { sem.buildTimeMomentRange(); return accept(); }
    if (TimeMomentPeriod_1())
    { sem.buildTimeMomentRangeWithStep(); return accept(); }
    return reject();
  }

  //-------------------------------------------------------------------
  //  TimeMomentPeriod_0 = TimeMoment (RangeOp / Colon) TimeMoment
  //-------------------------------------------------------------------
  private boolean TimeMomentPeriod_0()
  {
    begin("");
    if (!TimeMoment()) return rejectInner();
    if (!RangeOp()
            && !Colon()
            ) return rejectInner();
    if (!TimeMoment()) return rejectInner();
    return acceptInner();
  }

  //-------------------------------------------------------------------
  //  TimeMomentPeriod_1 = TimeMoment Colon TimeMomentStep Colon
  //    TimeMoment
  //-------------------------------------------------------------------
  private boolean TimeMomentPeriod_1()
  {
    begin("");
    if (!TimeMoment()) return rejectInner();
    if (!Colon()) return rejectInner();
    if (!TimeMomentStep()) return rejectInner();
    if (!Colon()) return rejectInner();
    if (!TimeMoment()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  Time = (TimeIndex / TimeMoment) {buildPassValue} ;
  //=====================================================================
  private boolean Time()
  {
    begin("Time");
    if (!TimeIndex()
            && !TimeMoment()
            ) return reject();
    sem.buildPassValue();
    return accept();
  }

  //=====================================================================
  //  TimeIndex = ("0" / "-" White* UInteger) {buildTimeIndex} ;
  //=====================================================================
  private boolean TimeIndex()
  {
    begin("TimeIndex");
    if (!next('0')
            && !TimeIndex_0()
            ) return reject();
    sem.buildTimeIndex();
    return accept();
  }

  //-------------------------------------------------------------------
  //  TimeIndex_0 = "-" White* UInteger
  //-------------------------------------------------------------------
  private boolean TimeIndex_0()
  {
    begin("");
    if (!next('-')) return rejectInner();
    while (White());
    if (!UInteger()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  TimeIndexStep = UInteger {buildPassValue} ;
  //=====================================================================
  private boolean TimeIndexStep()
  {
    begin("TimeIndexStep");
    if (!UInteger()) return reject();
    sem.buildPassValue();
    return accept();
  }

  //=====================================================================
  //  TimeMoment = ("0" TimeUnit? / "-" White* UInteger TimeUnit)
  //    {buildTimeMoment} ;
  //=====================================================================
  private boolean TimeMoment()
  {
    begin("TimeMoment");
    if (!TimeMoment_0()
            && !TimeMoment_1()
            ) return reject();
    sem.buildTimeMoment();
    return accept();
  }

  //-------------------------------------------------------------------
  //  TimeMoment_0 = "0" TimeUnit?
  //-------------------------------------------------------------------
  private boolean TimeMoment_0()
  {
    begin("");
    if (!next('0')) return rejectInner();
    TimeUnit();
    return acceptInner();
  }

  //-------------------------------------------------------------------
  //  TimeMoment_1 = "-" White* UInteger TimeUnit
  //-------------------------------------------------------------------
  private boolean TimeMoment_1()
  {
    begin("");
    if (!next('-')) return rejectInner();
    while (White());
    if (!UInteger()) return rejectInner();
    if (!TimeUnit()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  TimeMomentStep = UInteger TimeUnit {buildTimeMomentStep} ;
  //=====================================================================
  private boolean TimeMomentStep()
  {
    begin("TimeMomentStep");
    if (!UInteger()) return reject();
    if (!TimeUnit()) return reject();
    sem.buildTimeMomentStep();
    return accept();
  }

  //=====================================================================
  //  TimeUnit = White* ("ms" / "s" / "min" / "h") {buildTimeUnit} ;
  //=====================================================================
  private boolean TimeUnit()
  {
    begin("TimeUnit");
    while (White());
    if (!next("ms")
            && !next('s')
            && !next("min")
            && !next('h')
            ) return reject();
    sem.buildTimeUnit();
    return accept();
  }

  //=====================================================================
  //  ValuesList = (NumericValuesList / SymbolicValuesList)
  //    {buildPassValue} <list of values> ;
  //=====================================================================
  private boolean ValuesList()
  {
    begin("ValuesList","list of values");
    if (!NumericValuesList()
            && !SymbolicValuesList()
            ) return reject();
    sem.buildPassValue();
    return accept();
  }

  //=====================================================================
  //  NumericValuesList = LSbracket NumericValue (Comma NumericValue)*
  //    RSbracket {buildValuesList} <list of numeric values> ;
  //=====================================================================
  private boolean NumericValuesList()
  {
    begin("NumericValuesList","list of numeric values");
    if (!LSbracket()) return reject();
    if (!NumericValue()) return reject();
    while (NumericValuesList_0());
    if (!RSbracket()) return reject();
    sem.buildValuesList();
    return accept();
  }

  //-------------------------------------------------------------------
  //  NumericValuesList_0 = Comma NumericValue
  //-------------------------------------------------------------------
  private boolean NumericValuesList_0()
  {
    begin("");
    if (!Comma()) return rejectInner();
    if (!NumericValue()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  NumericValue = (NumberValuesRange / NumberValue) {buildPassValue}
  //    <numeric value> ;
  //=====================================================================
  private boolean NumericValue()
  {
    begin("NumericValue","numeric value");
    if (!NumberValuesRange()
            && !NumberValue()
            ) return reject();
    sem.buildPassValue();
    return accept();
  }

  //=====================================================================
  //  NumberValuesRange = NumberValue RangeOp NumberValue
  //    {buildValuesRange} <range of numbers> ;
  //=====================================================================
  private boolean NumberValuesRange()
  {
    begin("NumberValuesRange","range of numbers");
    if (!NumberValue()) return reject();
    if (!RangeOp()) return reject();
    if (!NumberValue()) return reject();
    sem.buildValuesRange();
    return accept();
  }

  //=====================================================================
  //  SymbolicValuesList = LSbracket SymbolicValue (Comma SymbolicValue)*
  //    RSbracket {buildValuesList} <list of symbolic values> ;
  //=====================================================================
  private boolean SymbolicValuesList()
  {
    begin("SymbolicValuesList","list of symbolic values");
    if (!LSbracket()) return reject();
    if (!SymbolicValue()) return reject();
    while (SymbolicValuesList_0());
    if (!RSbracket()) return reject();
    sem.buildValuesList();
    return accept();
  }

  //-------------------------------------------------------------------
  //  SymbolicValuesList_0 = Comma SymbolicValue
  //-------------------------------------------------------------------
  private boolean SymbolicValuesList_0()
  {
    begin("");
    if (!Comma()) return rejectInner();
    if (!SymbolicValue()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  SymbolicValue = (StringValuesRange / StringValue) {buildPassValue}
  //    <symbolic value> ;
  //=====================================================================
  private boolean SymbolicValue()
  {
    begin("SymbolicValue","symbolic value");
    if (!StringValuesRange()
            && !StringValue()
            ) return reject();
    sem.buildPassValue();
    return accept();
  }

  //=====================================================================
  //  StringValuesRange = StringValue RangeOp StringValue
  //    {buildValuesRange} <range of strings> ;
  //=====================================================================
  private boolean StringValuesRange()
  {
    begin("StringValuesRange","range of strings");
    if (!StringValue()) return reject();
    if (!RangeOp()) return reject();
    if (!StringValue()) return reject();
    sem.buildValuesRange();
    return accept();
  }

  //=====================================================================
  //  StringsList = LSbracket String (Comma String)* RSbracket
  //    {buildList} <list of string> ;
  //=====================================================================
  private boolean StringsList()
  {
    begin("StringsList","list of string");
    if (!LSbracket()) return reject();
    if (!String()) return reject();
    while (StringsList_0());
    if (!RSbracket()) return reject();
    sem.buildList();
    return accept();
  }

  //-------------------------------------------------------------------
  //  StringsList_0 = Comma String
  //-------------------------------------------------------------------
  private boolean StringsList_0()
  {
    begin("");
    if (!Comma()) return rejectInner();
    if (!String()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  IdentifiersList = LSbracket Identifier (Comma Identifier)*
  //    RSbracket {buildList} <list of foreign identifiers> ;
  //=====================================================================
  private boolean IdentifiersList()
  {
    begin("IdentifiersList","list of foreign identifiers");
    if (!LSbracket()) return reject();
    if (!Identifier()) return reject();
    while (IdentifiersList_0());
    if (!RSbracket()) return reject();
    sem.buildList();
    return accept();
  }

  //-------------------------------------------------------------------
  //  IdentifiersList_0 = Comma Identifier
  //-------------------------------------------------------------------
  private boolean IdentifiersList_0()
  {
    begin("");
    if (!Comma()) return rejectInner();
    if (!Identifier()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  OrderedStringValue = String Slash UInteger
  //    {buildOrderedStringValue} <ordered string> ;
  //=====================================================================
  private boolean OrderedStringValue()
  {
    begin("OrderedStringValue","ordered string");
    if (!String()) return reject();
    if (!Slash()) return reject();
    if (!UInteger()) return reject();
    sem.buildOrderedStringValue();
    return accept();
  }

  //=====================================================================
  //  StringValue = String {buildStringValue} <string> ;
  //=====================================================================
  private boolean StringValue()
  {
    begin("StringValue","string");
    if (!String()) return reject();
    sem.buildStringValue();
    return accept();
  }

  //=====================================================================
  //  String = (QuotedString / NormalString) {buildPassValue} <string> ;
  //=====================================================================
  private boolean String()
  {
    begin("String","string");
    if (!QuotedString()
            && !NormalString()
            ) return reject();
    sem.buildPassValue();
    return accept();
  }

  //=====================================================================
  //  QuotedString = "'" ^["'"]* "'" {buildQuotedString} <quoted string>
  //    ;
  //=====================================================================
  private boolean QuotedString()
  {
    begin("QuotedString","quoted string");
    if (!next('\'')) return reject();
    while (nextNotIn("\"'\""));
    if (!next('\'')) return reject();
    sem.buildQuotedString();
    return accept();
  }

  //=====================================================================
  //  NormalString = [a-z] ([a-z] / [A-Z] / [0-9] / "_")*
  //    {buildNormalString} <unquoted string> ;
  //=====================================================================
  private boolean NormalString()
  {
    begin("NormalString","unquoted string");
    if (!nextIn('a','z')) return reject();
    while (NormalString_0());
    sem.buildNormalString();
    return accept();
  }

  //-------------------------------------------------------------------
  //  NormalString_0 = [a-z] / [A-Z] / [0-9] / "_"
  //-------------------------------------------------------------------
  private boolean NormalString_0()
  {
    begin("");
    if (nextIn('a','z')) return acceptInner();
    if (nextIn('A','Z')) return acceptInner();
    if (nextIn('0','9')) return acceptInner();
    if (next('_')) return acceptInner();
    return rejectInner();
  }

  //=====================================================================
  //  Identifier = NormalString {buildPassValue} / "'" ([a-z] / [A-Z] /
  //    "_") ([a-z] / [A-Z] / "_" / [0-9] / ".")* "'" {buildQuotedString}
  //    <foreign identifier> ;
  //=====================================================================
  private boolean Identifier()
  {
    begin("Identifier","foreign identifier");
    if (NormalString())
    { sem.buildPassValue(); return accept(); }
    if (Identifier_0())
    { sem.buildQuotedString(); return accept(); }
    return reject();
  }

  //-------------------------------------------------------------------
  //  Identifier_0 = "'" ([a-z] / [A-Z] / "_") ([a-z] / [A-Z] / "_" /
  //    [0-9] / ".")* "'"
  //-------------------------------------------------------------------
  private boolean Identifier_0()
  {
    begin("");
    if (!next('\'')) return rejectInner();
    if (!nextIn('a','z')
            && !nextIn('A','Z')
            && !next('_')
            ) return rejectInner();
    while (Identifier_1());
    if (!next('\'')) return rejectInner();
    return acceptInner();
  }

  //-------------------------------------------------------------------
  //  Identifier_1 = [a-z] / [A-Z] / "_" / [0-9] / "."
  //-------------------------------------------------------------------
  private boolean Identifier_1()
  {
    begin("");
    if (nextIn('a','z')) return acceptInner();
    if (nextIn('A','Z')) return acceptInner();
    if (next('_')) return acceptInner();
    if (nextIn('0','9')) return acceptInner();
    if (next('.')) return acceptInner();
    return rejectInner();
  }

  //=====================================================================
  //  NumberValue = (FloatValue / IntegerValue) {buildPassValue} <number>
  //    ;
  //=====================================================================
  private boolean NumberValue()
  {
    begin("NumberValue","number");
    if (!FloatValue()
            && !IntegerValue()
            ) return reject();
    sem.buildPassValue();
    return accept();
  }

  //=====================================================================
  //  Number = (Float / Integer) {buildPassValue} <number> ;
  //=====================================================================
  private boolean Number()
  {
    begin("Number","number");
    if (!Float()
            && !Integer()
            ) return reject();
    sem.buildPassValue();
    return accept();
  }

  //=====================================================================
  //  Percent = (UFloat / UInteger) "%"? {buildPercent} <percent> ;
  //=====================================================================
  private boolean Percent()
  {
    begin("Percent","percent");
    if (!UFloat()
            && !UInteger()
            ) return reject();
    next('%');
    sem.buildPercent();
    return accept();
  }

  //=====================================================================
  //  FloatValue = Float {buildNumberFloatValue} <float> ;
  //=====================================================================
  private boolean FloatValue()
  {
    begin("FloatValue","float");
    if (!Float()) return reject();
    sem.buildNumberFloatValue();
    return accept();
  }

  //=====================================================================
  //  Float = ("-" White*)? UFloat {buildSignedFloat} <float> ;
  //=====================================================================
  private boolean Float()
  {
    begin("Float","float");
    Float_0();
    if (!UFloat()) return reject();
    sem.buildSignedFloat();
    return accept();
  }

  //-------------------------------------------------------------------
  //  Float_0 = "-" White*
  //-------------------------------------------------------------------
  private boolean Float_0()
  {
    begin("");
    if (!next('-')) return rejectInner();
    while (White());
    return acceptInner();
  }

  //=====================================================================
  //  UFloat = [0-9]+ "." [0-9]+ {buildUnsignedFloat} <unsigned float> ;
  //=====================================================================
  private boolean UFloat()
  {
    begin("UFloat","unsigned float");
    if (!nextIn('0','9')) return reject();
    while (nextIn('0','9'));
    if (!next('.')) return reject();
    if (!nextIn('0','9')) return reject();
    while (nextIn('0','9'));
    sem.buildUnsignedFloat();
    return accept();
  }

  //=====================================================================
  //  IntegerValue = Integer {buildNumberIntValue} <integer> ;
  //=====================================================================
  private boolean IntegerValue()
  {
    begin("IntegerValue","integer");
    if (!Integer()) return reject();
    sem.buildNumberIntValue();
    return accept();
  }

  //=====================================================================
  //  Integer = ("-" White*)? UInteger {buildSignedInteger} <integer> ;
  //=====================================================================
  private boolean Integer()
  {
    begin("Integer","integer");
    Float_0();
    if (!UInteger()) return reject();
    sem.buildSignedInteger();
    return accept();
  }

  //=====================================================================
  //  UInteger = [0-9]+ {buildUnsignedInteger} <unsigned integer> ;
  //=====================================================================
  private boolean UInteger()
  {
    begin("UInteger","unsigned integer");
    if (!nextIn('0','9')) return reject();
    while (nextIn('0','9'));
    sem.buildUnsignedInteger();
    return accept();
  }

  //=====================================================================
  //  Skip = (Comment / Clause / White) {passSkip} <skippable element> ;
  //=====================================================================
  private boolean Skip()
  {
    begin("Skip","skippable element");
    if (!Comment()
            && !Clause()
            && !White()
            ) return reject();
    sem.passSkip();
    return accept();
  }

  //=====================================================================
  //  Comment = "%" _*+ EOL / CommentStart _*+ CommentEnd <comment> ;
  //=====================================================================
  private boolean Comment()
  {
    begin("Comment","comment");
    if (Comment_0()) return accept();
    if (Comment_1()) return accept();
    return reject();
  }

  //-------------------------------------------------------------------
  //  Comment_0 = "%" _*+ EOL
  //-------------------------------------------------------------------
  private boolean Comment_0()
  {
    begin("");
    if (!next('%')) return rejectInner();
    while (!EOL())
      if (!next()) return rejectInner();
    return acceptInner();
  }

  //-------------------------------------------------------------------
  //  Comment_1 = CommentStart _*+ CommentEnd
  //-------------------------------------------------------------------
  private boolean Comment_1()
  {
    begin("");
    if (!CommentStart()) return rejectInner();
    while (!CommentEnd())
      if (!next()) return rejectInner();
    return acceptInner();
  }

  //=====================================================================
  //  CommentStart = "/*" ;
  //=====================================================================
  private boolean CommentStart()
  {
    begin("CommentStart");
    if (!next("/*")) return reject();
    return accept();
  }

  //=====================================================================
  //  CommentEnd = "*/" ;
  //=====================================================================
  private boolean CommentEnd()
  {
    begin("CommentEnd");
    if (!next("*/")) return reject();
    return accept();
  }

  //=====================================================================
  //  Clause = ":-" (String / ^["."])* "." <prolog clause> ;
  //=====================================================================
  private boolean Clause()
  {
    begin("Clause","prolog clause");
    if (!next(":-")) return reject();
    while (Clause_0());
    if (!next('.')) return reject();
    return accept();
  }

  //-------------------------------------------------------------------
  //  Clause_0 = String / ^["."]
  //-------------------------------------------------------------------
  private boolean Clause_0()
  {
    begin("");
    if (String()) return acceptInner();
    if (nextNotIn("\".\"")) return acceptInner();
    return rejectInner();
  }

  //=====================================================================
  //  White = [ \t\r\n] <whitespace character> ;
  //=====================================================================
  private boolean White()
  {
    begin("White","whitespace character");
    if (!nextIn(" \t\r\n")) return reject();
    return accept();
  }

  //=====================================================================
  //  EOL = [\n\r]+ / EOF <end of line> ;
  //=====================================================================
  private boolean EOL()
  {
    begin("EOL","end of line");
    if (EOL_0()) return accept();
    if (EOF()) return accept();
    return reject();
  }

  //-------------------------------------------------------------------
  //  EOL_0 = [\n\r]+
  //-------------------------------------------------------------------
  private boolean EOL_0()
  {
    begin("");
    if (!nextIn("\n\r")) return rejectInner();
    while (nextIn("\n\r"));
    return acceptInner();
  }

  //=====================================================================
  //  EOF = !_ <end of file> ;
  //=====================================================================
  private boolean EOF()
  {
    begin("EOF","end of file");
    if (!aheadNot()) return reject();
    return accept();
  }

}
